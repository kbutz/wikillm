// Memory Explorer Utility
// This utility helps you explore and examine the memory data generated by WikiLLM
//
// Usage: go run memory_explorer.go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	fmt.Println("=== WikiLLM Memory Explorer ===")
	
	// Get current directory and check for memory folder
	examplesDir, err := os.Getwd()
	if err != nil {
		log.Fatalf("Failed to get current directory: %v", err)
	}
	
	memoryBaseDir := filepath.Join(examplesDir, "wikillm_memory")
	memoryDir := filepath.Join(memoryBaseDir, "memory")
	
	// Check if memory directory exists
	if _, err := os.Stat(memoryDir); os.IsNotExist(err) {
		fmt.Printf("❌ Memory directory not found: %s\n", memoryDir)
		fmt.Println("Run the interactive example first to generate memory data.")
		return
	}
	
	fmt.Printf("📁 Exploring memory directory: %s\n\n", memoryDir)
	
	// Walk through the memory directory
	err = filepath.Walk(memoryDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		
		// Skip directories
		if info.IsDir() {
			return nil
		}
		
		// Get relative path from memory directory
		relPath, _ := filepath.Rel(memoryDir, path)
		
		fmt.Printf("📄 File: %s\n", relPath)
		fmt.Printf("   Size: %d bytes\n", info.Size())
		fmt.Printf("   Modified: %s\n", info.ModTime().Format(time.RFC3339))
		
		// Try to read and display the content
		content, err := ioutil.ReadFile(path)
		if err != nil {
			fmt.Printf("   ❌ Error reading file: %v\n", err)
		} else {
			displayContent(relPath, content)
		}
		
		fmt.Println()
		return nil
	})
	
	if err != nil {
		log.Fatalf("Error walking memory directory: %v", err)
	}
	
	fmt.Println("=== Memory exploration complete ===")
	fmt.Println("\nMemory file types you might see:")
	fmt.Println("- conversation:* - Conversation history and context")
	fmt.Println("- agent:*:init - Agent initialization data")
	fmt.Println("- msg:* - Individual messages")
	fmt.Println("- orchestrator:* - Orchestrator events and data")
}

func displayContent(filename string, content []byte) {
	// Try to parse as JSON first
	var jsonData interface{}
	if err := json.Unmarshal(content, &jsonData); err == nil {
		// It's JSON, pretty print it
		prettyJSON, err := json.MarshalIndent(jsonData, "   ", "  ")
		if err == nil {
			fmt.Printf("   💾 Content (JSON):\n%s\n", addIndent(string(prettyJSON), "   "))
			return
		}
	}
	
	// Not JSON, display as text (truncated if too long)
	contentStr := string(content)
	if len(contentStr) > 200 {
		contentStr = contentStr[:200] + "... (truncated)"
	}
	
	// Replace newlines with visual indicators for better display
	contentStr = strings.ReplaceAll(contentStr, "\n", "\\n")
	fmt.Printf("   💾 Content (text): %s\n", contentStr)
}

func addIndent(text, indent string) string {
	lines := strings.Split(text, "\n")
	var result []string
	for _, line := range lines {
		result = append(result, indent+line)
	}
	return strings.Join(result, "\n")
}
