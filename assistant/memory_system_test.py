#!/usr/bin/env python\n\"\"\"\nComprehensive Memory System Health Check and Testing\n\"\"\"\nimport asyncio\nimport json\nimport logging\nimport sys\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Any\n\n# Add current directory to path\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\n\nfrom sqlalchemy import text\nfrom database import get_db_session\nfrom models import User, Conversation, ConversationSummary, UserMemory, Message\nfrom memory_manager import MemoryManager, EnhancedMemoryManager\nfrom search_manager import SearchManager\nfrom conversation_manager import ConversationManager\nfrom config import settings\n\nlogger = logging.getLogger(__name__)\n\n\nclass MemorySystemTester:\n    \"\"\"Comprehensive memory system testing suite\"\"\"\n    \n    def __init__(self):\n        self.db_session = None\n        self.test_user_id = None\n        self.test_results = {\n            \"database_health\": {},\n            \"memory_extraction\": {},\n            \"cross_conversation_search\": {},\n            \"implicit_explicit_memory\": {},\n            \"performance_metrics\": {}\n        }\n    \n    def setup_test_environment(self):\n        \"\"\"Set up test environment with a test user\"\"\"\n        try:\n            with get_db_session() as db:\n                # Create or get test user\n                test_user = db.query(User).filter(User.username == \"memory_test_user\").first()\n                if not test_user:\n                    test_user = User(\n                        username=\"memory_test_user\",\n                        email=\"test@example.com\",\n                        full_name=\"Memory Test User\"\n                    )\n                    db.add(test_user)\n                    db.commit()\n                    db.refresh(test_user)\n                    logger.info(f\"Created test user with ID: {test_user.id}\")\n                \n                self.test_user_id = test_user.id\n                return True\n                \n        except Exception as e:\n            logger.error(f\"Failed to set up test environment: {e}\")\n            return False\n    \n    def test_database_health(self):\n        \"\"\"Test database health and schema integrity\"\"\"\n        logger.info(\"Testing database health...\")\n        \n        try:\n            with get_db_session() as db:\n                # Check table existence\n                tables = db.execute(text(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")).fetchall()\n                table_names = [table.name for table in tables]\n                \n                required_tables = ['users', 'conversations', 'messages', 'user_memory', 'user_preferences', 'conversation_summaries']\n                missing_tables = [table for table in required_tables if table not in table_names]\n                \n                self.test_results[\"database_health\"][\"tables_exist\"] = len(missing_tables) == 0\n                self.test_results[\"database_health\"][\"missing_tables\"] = missing_tables\n                \n                # Check FTS table\n                fts_exists = db.execute(text(\"SELECT name FROM sqlite_master WHERE type='table' AND name='conversation_summaries_fts'\")).fetchone()\n                self.test_results[\"database_health\"][\"fts_table_exists\"] = fts_exists is not None\n                \n                # Check data counts\n                user_count = db.execute(text(\"SELECT COUNT(*) FROM users\")).scalar()\n                conversation_count = db.execute(text(\"SELECT COUNT(*) FROM conversations\")).scalar()\n                memory_count = db.execute(text(\"SELECT COUNT(*) FROM user_memory\")).scalar()\n                \n                self.test_results[\"database_health\"][\"data_counts\"] = {\n                    \"users\": user_count,\n                    \"conversations\": conversation_count,\n                    \"memories\": memory_count\n                }\n                \n                logger.info(f\"Database health check completed: {self.test_results['database_health']}\")\n                return True\n                \n        except Exception as e:\n            logger.error(f\"Database health check failed: {e}\")\n            self.test_results[\"database_health\"][\"error\"] = str(e)\n            return False\n    \n    async def test_memory_extraction(self):\n        \"\"\"Test memory extraction functionality\"\"\"\n        logger.info(\"Testing memory extraction...\")\n        \n        try:\n            with get_db_session() as db:\n                enhanced_memory = EnhancedMemoryManager(db)\n                \n                # Test cases for memory extraction\n                test_cases = [\n                    {\n                        \"user_message\": \"Hi, my name is John and I have a dog named Max who is 5 years old. I work as a software engineer.\",\n                        \"assistant_response\": \"Hello John! It's nice to meet you. Tell me more about Max - what breed is he?\",\n                        \"expected_facts\": [\"name\", \"pet_dog_name\", \"profession\", \"pet_age\"]\n                    },\n                    {\n                        \"user_message\": \"I prefer concise responses and I'm from Seattle. My favorite food is pizza.\",\n                        \"assistant_response\": \"Got it! I'll keep my responses brief. Seattle is a great city.\",\n                        \"expected_facts\": [\"response_style\", \"location\", \"favorite_food\"]\n                    },\n                    {\n                        \"user_message\": \"I'm planning a trip to Paris in June and I need to renew my passport.\",\n                        \"assistant_response\": \"That sounds like an exciting trip! Make sure to renew your passport well in advance.\",\n                        \"expected_facts\": [\"travel_destination\", \"travel_month\", \"passport_renewal\"]\n                    }\n                ]\n                \n                extraction_results = []\n                for i, test_case in enumerate(test_cases):\n                    try:\n                        # Extract memories\n                        memories = await enhanced_memory.extract_and_store_facts(\n                            self.test_user_id,\n                            test_case[\"user_message\"],\n                            test_case[\"assistant_response\"],\n                            conversation_id=1  # Use a test conversation ID\n                        )\n                        \n                        extraction_results.append({\n                            \"test_case\": i + 1,\n                            \"memories_extracted\": len(memories),\n                            \"memory_keys\": [m.key for m in memories] if memories else [],\n                            \"success\": len(memories) > 0\n                        })\n                        \n                        logger.info(f\"Test case {i+1}: Extracted {len(memories)} memories\")\n                        \n                    except Exception as e:\n                        extraction_results.append({\n                            \"test_case\": i + 1,\n                            \"error\": str(e),\n                            \"success\": False\n                        })\n                        logger.error(f\"Test case {i+1} failed: {e}\")\n                \n                self.test_results[\"memory_extraction\"][\"test_cases\"] = extraction_results\n                self.test_results[\"memory_extraction\"][\"success_rate\"] = sum(1 for r in extraction_results if r[\"success\"]) / len(extraction_results)\n                \n                return True\n                \n        except Exception as e:\n            logger.error(f\"Memory extraction test failed: {e}\")\n            self.test_results[\"memory_extraction\"][\"error\"] = str(e)\n            return False\n    \n    async def test_cross_conversation_search(self):\n        \"\"\"Test cross-conversation search functionality\"\"\"\n        logger.info(\"Testing cross-conversation search...\")\n        \n        try:\n            with get_db_session() as db:\n                search_manager = SearchManager(db)\n                \n                # Test search queries\n                test_queries = [\"dog\", \"Seattle\", \"travel\", \"passport\", \"software engineer\"]\n                \n                search_results = []\n                for query in test_queries:\n                    try:\n                        results = await search_manager.search_conversations(\n                            self.test_user_id,\n                            query,\n                            limit=5\n                        )\n                        \n                        search_results.append({\n                            \"query\": query,\n                            \"results_found\": len(results),\n                            \"success\": True\n                        })\n                        \n                        logger.info(f\"Search query '{query}': Found {len(results)} results\")\n                        \n                    except Exception as e:\n                        search_results.append({\n                            \"query\": query,\n                            \"error\": str(e),\n                            \"success\": False\n                        })\n                        logger.error(f\"Search query '{query}' failed: {e}\")\n                \n                self.test_results[\"cross_conversation_search\"][\"test_queries\"] = search_results\n                self.test_results[\"cross_conversation_search\"][\"fts_available\"] = search_manager.fts_available\n                \n                return True\n                \n        except Exception as e:\n            logger.error(f\"Cross-conversation search test failed: {e}\")\n            self.test_results[\"cross_conversation_search\"][\"error\"] = str(e)\n            return False\n    \n    def test_implicit_explicit_memory(self):\n        \"\"\"Test implicit vs explicit memory classification\"\"\"\n        logger.info(\"Testing implicit vs explicit memory classification...\")\n        \n        try:\n            with get_db_session() as db:\n                # Get stored memories for test user\n                explicit_memories = db.query(UserMemory).filter(\n                    UserMemory.user_id == self.test_user_id,\n                    UserMemory.memory_type == \"explicit\"\n                ).all()\n                \n                implicit_memories = db.query(UserMemory).filter(\n                    UserMemory.user_id == self.test_user_id,\n                    UserMemory.memory_type == \"implicit\"\n                ).all()\n                \n                self.test_results[\"implicit_explicit_memory\"][\"explicit_count\"] = len(explicit_memories)\n                self.test_results[\"implicit_explicit_memory\"][\"implicit_count\"] = len(implicit_memories)\n                \n                # Check confidence scores\n                explicit_confidence = [m.confidence for m in explicit_memories]\n                implicit_confidence = [m.confidence for m in implicit_memories]\n                \n                self.test_results[\"implicit_explicit_memory\"][\"explicit_avg_confidence\"] = sum(explicit_confidence) / len(explicit_confidence) if explicit_confidence else 0\n                self.test_results[\"implicit_explicit_memory\"][\"implicit_avg_confidence\"] = sum(implicit_confidence) / len(implicit_confidence) if implicit_confidence else 0\n                \n                # Check memory keys\n                self.test_results[\"implicit_explicit_memory\"][\"explicit_memory_keys\"] = [m.key for m in explicit_memories[:5]]  # Top 5\n                self.test_results[\"implicit_explicit_memory\"][\"implicit_memory_keys\"] = [m.key for m in implicit_memories[:5]]  # Top 5\n                \n                logger.info(f\"Memory classification test completed: {len(explicit_memories)} explicit, {len(implicit_memories)} implicit\")\n                return True\n                \n        except Exception as e:\n            logger.error(f\"Memory classification test failed: {e}\")\n            self.test_results[\"implicit_explicit_memory\"][\"error\"] = str(e)\n            return False\n    \n    def test_performance_metrics(self):\n        \"\"\"Test performance metrics\"\"\"\n        logger.info(\"Testing performance metrics...\")\n        \n        try:\n            with get_db_session() as db:\n                # Memory access patterns\n                memory_access_stats = db.execute(text(\"\"\"\n                    SELECT \n                        COUNT(*) as total_memories,\n                        AVG(access_count) as avg_access_count,\n                        MAX(access_count) as max_access_count,\n                        COUNT(CASE WHEN access_count > 1 THEN 1 END) as accessed_memories\n                    FROM user_memory \n                    WHERE user_id = :user_id\n                \"\"\"), {\"user_id\": self.test_user_id}).fetchone()\n                \n                if memory_access_stats:\n                    self.test_results[\"performance_metrics\"][\"memory_stats\"] = {\n                        \"total_memories\": memory_access_stats.total_memories,\n                        \"avg_access_count\": float(memory_access_stats.avg_access_count) if memory_access_stats.avg_access_count else 0,\n                        \"max_access_count\": memory_access_stats.max_access_count,\n                        \"accessed_memories\": memory_access_stats.accessed_memories\n                    }\n                \n                # Conversation summary stats\n                summary_stats = db.execute(text(\"\"\"\n                    SELECT \n                        COUNT(*) as total_summaries,\n                        AVG(priority_score) as avg_priority_score,\n                        COUNT(CASE WHEN keywords IS NOT NULL AND keywords != '' THEN 1 END) as summaries_with_keywords\n                    FROM conversation_summaries cs\n                    JOIN conversations c ON c.id = cs.conversation_id\n                    WHERE c.user_id = :user_id\n                \"\"\"), {\"user_id\": self.test_user_id}).fetchone()\n                \n                if summary_stats:\n                    self.test_results[\"performance_metrics\"][\"summary_stats\"] = {\n                        \"total_summaries\": summary_stats.total_summaries,\n                        \"avg_priority_score\": float(summary_stats.avg_priority_score) if summary_stats.avg_priority_score else 0,\n                        \"summaries_with_keywords\": summary_stats.summaries_with_keywords\n                    }\n                \n                return True\n                \n        except Exception as e:\n            logger.error(f\"Performance metrics test failed: {e}\")\n            self.test_results[\"performance_metrics\"][\"error\"] = str(e)\n            return False\n    \n    async def run_all_tests(self):\n        \"\"\"Run all tests and generate comprehensive report\"\"\"\n        logger.info(\"Starting comprehensive memory system testing...\")\n        \n        start_time = datetime.now()\n        \n        # Setup test environment\n        if not self.setup_test_environment():\n            logger.error(\"Failed to set up test environment\")\n            return False\n        \n        # Run all tests\n        tests = [\n            (\"Database Health\", self.test_database_health),\n            (\"Memory Extraction\", self.test_memory_extraction),\n            (\"Cross-Conversation Search\", self.test_cross_conversation_search),\n            (\"Implicit/Explicit Memory\", self.test_implicit_explicit_memory),\n            (\"Performance Metrics\", self.test_performance_metrics)\n        ]\n        \n        passed_tests = 0\n        \n        for test_name, test_func in tests:\n            logger.info(f\"Running {test_name} test...\")\n            try:\n                if asyncio.iscoroutinefunction(test_func):\n                    result = await test_func()\n                else:\n                    result = test_func()\n                \n                if result:\n                    logger.info(f\"✓ {test_name} test passed\")\n                    passed_tests += 1\n                else:\n                    logger.error(f\"✗ {test_name} test failed\")\n                    \n            except Exception as e:\n                logger.error(f\"✗ {test_name} test failed with exception: {e}\")\n        \n        end_time = datetime.now()\n        test_duration = (end_time - start_time).total_seconds()\n        \n        # Generate final report\n        self.test_results[\"summary\"] = {\n            \"total_tests\": len(tests),\n            \"passed_tests\": passed_tests,\n            \"failed_tests\": len(tests) - passed_tests,\n            \"success_rate\": passed_tests / len(tests),\n            \"test_duration_seconds\": test_duration,\n            \"timestamp\": end_time.isoformat()\n        }\n        \n        return passed_tests == len(tests)\n    \n    def generate_report(self):\n        \"\"\"Generate comprehensive test report\"\"\"\n        report = {\n            \"test_results\": self.test_results,\n            \"recommendations\": self._generate_recommendations(),\n            \"config_settings\": {\n                \"max_conversation_history\": settings.max_conversation_history,\n                \"max_user_memory_entries\": settings.max_user_memory_entries,\n                \"memory_consolidation_threshold\": settings.memory_consolidation_threshold,\n                \"auto_summarize_after_messages\": settings.auto_summarize_after_messages,\n                \"max_search_results\": settings.max_search_results,\n                \"fts_search_enabled\": getattr(settings, 'fts_search_enabled', False)\n            }\n        }\n        \n        return report\n    \n    def _generate_recommendations(self) -> List[str]:\n        \"\"\"Generate recommendations based on test results\"\"\"\n        recommendations = []\n        \n        # Database health recommendations\n        if not self.test_results[\"database_health\"].get(\"fts_table_exists\", False):\n            recommendations.append(\"Run database migration to create FTS table for improved search performance\")\n        \n        # Memory extraction recommendations\n        memory_success_rate = self.test_results[\"memory_extraction\"].get(\"success_rate\", 0)\n        if memory_success_rate < 0.8:\n            recommendations.append(f\"Memory extraction success rate is {memory_success_rate:.2%}. Consider tuning LLM parameters\")\n        \n        # Search recommendations\n        if not self.test_results[\"cross_conversation_search\"].get(\"fts_available\", False):\n            recommendations.append(\"FTS search is not available. Cross-conversation search will use fallback method\")\n        \n        # Memory balance recommendations\n        explicit_count = self.test_results[\"implicit_explicit_memory\"].get(\"explicit_count\", 0)\n        implicit_count = self.test_results[\"implicit_explicit_memory\"].get(\"implicit_count\", 0)\n        \n        if explicit_count == 0 and implicit_count > 0:\n            recommendations.append(\"No explicit memories found. Consider adjusting confidence thresholds\")\n        \n        if explicit_count > 0 and implicit_count == 0:\n            recommendations.append(\"No implicit memories found. Check implicit memory extraction functionality\")\n        \n        # Performance recommendations\n        memory_stats = self.test_results[\"performance_metrics\"].get(\"memory_stats\", {})\n        if memory_stats.get(\"avg_access_count\", 0) < 1.5:\n            recommendations.append(\"Low memory access frequency. Consider improving memory relevance scoring\")\n        \n        return recommendations\n\n\nasync def main():\n    \"\"\"Main testing function\"\"\"\n    # Setup logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    # Create and run tester\n    tester = MemorySystemTester()\n    \n    try:\n        success = await tester.run_all_tests()\n        report = tester.generate_report()\n        \n        # Print summary\n        print(\"\\n\" + \"=\"*60)\n        print(\"MEMORY SYSTEM TEST REPORT\")\n        print(\"=\"*60)\n        \n        summary = report[\"test_results\"][\"summary\"]\n        print(f\"\\nTEST SUMMARY:\")\n        print(f\"Total Tests: {summary['total_tests']}\")\n        print(f\"Passed: {summary['passed_tests']}\")\n        print(f\"Failed: {summary['failed_tests']}\")\n        print(f\"Success Rate: {summary['success_rate']:.2%}\")\n        print(f\"Duration: {summary['test_duration_seconds']:.2f} seconds\")\n        \n        if success:\n            print(\"\\n✅ ALL TESTS PASSED!\")\n        else:\n            print(\"\\n❌ SOME TESTS FAILED!\")\n        \n        # Print recommendations\n        if report[\"recommendations\"]:\n            print(\"\\nRECOMMENDATIONS:\")\n            for i, rec in enumerate(report[\"recommendations\"], 1):\n                print(f\"{i}. {rec}\")\n        \n        # Save detailed report\n        with open(f\"memory_system_test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\", \"w\") as f:\n            json.dump(report, f, indent=2, default=str)\n        \n        print(f\"\\nDetailed report saved to: memory_system_test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\")\n        \n        return success\n        \n    except Exception as e:\n        logger.error(f\"Testing failed with exception: {e}\")\n        print(f\"\\n❌ TESTING FAILED: {e}\")\n        return False\n\n\nif __name__ == \"__main__\":\n    success = asyncio.run(main())\n    sys.exit(0 if success else 1)\n